// Copyright Wiktor Wilga (wilgawiktor@gmail.com)


#include "GOAPSetWorldStateValue.h"

#include "EdGraphSchema_K2.h"
#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "GOAPTypes.h"
#include "GOAPWorldStatePayloads.h"
#include "K2Node_CallFunction.h"

#define LOCTEXT_NAMESPACE "GOAPSetWorldStateValue"

struct FGetPinName_SetWorldState
{

	static const FName& GetTargetPinName()
	{
		static const FName TargetPinName(TEXT("Target"));
		return TargetPinName;
	}

	static const FName& GetNewValuePinName()
	{
		static const FName NewValuePinName(TEXT("NewValue"));
		return NewValuePinName;
	}

	static const FName& GetResultPinName()
	{
		static const FName ResultPinName(TEXT("Result"));
		return ResultPinName;
	}
};

void UGOAPSetWorldStateValue::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
	
	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	// Input
	UEdGraphNode::FCreatePinParams PinParams;
	PinParams.bIsReference = true;
	
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, FGOAPWorldStateValue::StaticStruct(),
		FGetPinName_SetWorldState::GetTargetPinName(), PinParams);
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, FGetPinName_SetWorldState::GetNewValuePinName());

	// Output
	UEdGraphPin* OutPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Struct, FGOAPWorldStateValue::StaticStruct(),
		FGetPinName_SetWorldState::GetResultPinName());
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutPin);
	
	Super::AllocateDefaultPins();
}

/// These three functions make the node appear as an option;
FText UGOAPSetWorldStateValue::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("GOAPSetWorldStateValue_Title", "Set World State Value");
}

FText UGOAPSetWorldStateValue::GetTooltipText() const
{
	return LOCTEXT("GOAPSetWorldStateValue_Tooltip", "Sets the value of a FGOAPWorldStateValue.");
}

void UGOAPSetWorldStateValue::PostReconstructNode()
{
	Super::PostReconstructNode();

	// If something was connected to wildcard pin we needs restore that type for pin
	UEdGraphPin* NewValuePin = GetNewValuePin();
	if(NewValuePin && NewValuePin->LinkedTo.Num() > 0)
	{
		NewValuePin->PinType.PinCategory = NewValuePin->LinkedTo[0]->PinType.PinCategory;
		NewValuePin->PinType.PinSubCategory = NewValuePin->LinkedTo[0]->PinType.PinSubCategory;
		NewValuePin->PinType.PinSubCategoryObject = NewValuePin->LinkedTo[0]->PinType.PinSubCategoryObject;
	}
}

FText UGOAPSetWorldStateValue::GetMenuCategory() const
{
	return LOCTEXT("SetObjVarByNameK2Node_MenuCategory", "GOAP");
}
/// end

void UGOAPSetWorldStateValue::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	const UEdGraphPin* NewValuePin = GetNewValuePin();

	// Find type of variable connected to wildcard pin
	const UClass* PinClass = nullptr;
	if(NewValuePin->PinType.PinSubCategoryObject.IsValid())
	{
		PinClass = NewValuePin->PinType.PinSubCategoryObject.Get()->StaticClass();
	}

	// Get all payload classes
	TArray<UClass*> PayloadsTypes;
	GetDerivedClasses(UGOAPWorldStatePayload::StaticClass(), PayloadsTypes);
	
	// Find payload class associated with wildcard pin
	UClass* PayloadClass = nullptr;
	for(UClass* Type : PayloadsTypes)
	{
		const FProperty* ValueFProperty = FindFProperty<FProperty>(Type, "Value");
		FName PinCategory, PinSubCategory;
		UObject* PinSubCategoryObject = nullptr;
		bool PinIsWeakPtr;
		UEdGraphSchema_K2::GetPropertyCategoryInfo(ValueFProperty, PinCategory,
			PinSubCategory, PinSubCategoryObject, PinIsWeakPtr);
		
		const UClass* TmpClass = nullptr;
		if(PinSubCategoryObject && PinSubCategoryObject->IsValidLowLevel())
		{
			TmpClass = PinSubCategoryObject->StaticClass();
		}
		if(NewValuePin->PinType.PinCategory == PinCategory &&
			NewValuePin->PinType.PinSubCategory == PinSubCategory &&
			TmpClass == PinClass)
		{
			PayloadClass = Type;
			break;
		}
	}

	const UFunction* BlueprintFunction = FindSetterFunctionByType(PayloadClass);

	if (!BlueprintFunction)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
		return;
	}

	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallFunction->SetFromFunction(BlueprintFunction);
	CallFunction->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	// Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName_SetWorldState::GetTargetPinName()),
		*CallFunction->FindPinChecked(TEXT("WorldStateValue")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName_SetWorldState::GetNewValuePinName()),
		*CallFunction->FindPinChecked(TEXT("InValue")));
	
	// Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName_SetWorldState::GetResultPinName()),
			*CallFunction->GetReturnValuePin());

	// Exec pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	// After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

// This method adds our node to the context menu
void UGOAPSetWorldStateValue::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	const UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action))
	{
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

void UGOAPSetWorldStateValue::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	UEdGraphPin* NewValuePin = GetNewValuePin();

	if ((Pin == NewValuePin))
	{
		const UEdGraphPin* ConnectedToPin = (Pin->LinkedTo.Num() > 0) ? Pin->LinkedTo[0] : nullptr;
		if (ConnectedToPin)
		{
			NewValuePin->PinType = ConnectedToPin->PinType;
		}
		else
		{
			NewValuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			NewValuePin->PinType.PinSubCategory = NAME_None;
			NewValuePin->PinType.PinSubCategoryObject = nullptr;
		}
	}
}

/// Pin getters
UEdGraphPin* UGOAPSetWorldStateValue::GetThenPin() const
{
	UEdGraphPin* Pin = FindPinChecked(UEdGraphSchema_K2::PN_Then);
	return Pin;
}

UEdGraphPin* UGOAPSetWorldStateValue::GetTargetPin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName_SetWorldState::GetTargetPinName());
	return Pin;
}

UEdGraphPin* UGOAPSetWorldStateValue::GetNewValuePin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName_SetWorldState::GetNewValuePinName());
	return Pin;
}

UEdGraphPin* UGOAPSetWorldStateValue::GetResultPin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName_SetWorldState::GetResultPinName());
	return Pin;
}

UFunction* UGOAPSetWorldStateValue::FindSetterFunctionByType(TSubclassOf<UGOAPWorldStatePayload> PayloadClass)
{
	if(!PayloadClass)
	{
		return nullptr;
	}

	return PayloadClass->FindFunctionByName("SetPayloadValue");
}

#undef LOCTEXT_NAMESPACE